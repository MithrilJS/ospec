"use strict"
// const LOG = console.log
// const p = (...args) => {
// 	LOG(...args)
// 	return args.pop()
// }

/*
Ospec is made of four parts:

1. a test definition API That creates a spec/tests tree
2. a test runner that walks said spec tree
3. an assertion API that populates a results array
4. a reporter which presents the results

The tepmoral sequence at run time is 1 then (2 and 3), then 4

The various sections (and sub-sections thereof) share information through stack-managed globals
which are enumerated in the "Setup" section below.

there are three kind of data structures, that reflect the above segregation:

1. Specs, that group other specs and tasks
2. Tasks, that represent hooks and tests, and internal logic
3. Assertions which end up in the results array.

At run-time, the specs are converted to lists of task (one per entry in the spec)
In each of these tasks:
- sub-specs receive the same treament as their parent, when their turn comes.
- tests are also turned into lists of tasks [...beforeEach, test, ...afterEach]
*/


;(function(m) {
if (typeof module !== "undefined") module["exports"] = m()
else window.o = m()
})(function init(name) {
	// # Setup
	// const
	var hasProcess = typeof process === "object", hasOwn = ({}).hasOwnProperty

	var hasSuiteName = arguments.length !== 0
	var only = []
	var ospecFileName = getStackName(ensureStackTrace(new Error), /[\/\\](.*?):\d+:\d+/)
	var rootSpec = new Spec()
	var subjects = []

	// stack-managed globals

	// Are we in the process of baling out?
	var $bail = false
	// current spec
	var $context = rootSpec
	// spec nesting level
	var $depth = 1
	// the current file name
	var $file
	// the task (test/hook) that is currently running
	var $task = null
	// the current o.timeout implementation
	var $timeout
	// count the total amount of tests that timed out and didn't complete after the fact before the run ends
	var $timedOutAndPendingResolution = 0
	// are we using the v5+ API?
	var $localAssertions = false
	// Shared state, set only once, but initialization is delayed
	var results, stats, timeoutStackName

	// # General utils
	function isRunning() {return results != null}

	function ensureStackTrace(error) {
		// mandatory to get a stack in IE 10 and 11 (and maybe other envs?)
		if (error.stack === undefined) try { throw error } catch(e) {return e}
		else return error
	}

	function getStackName(e, exp) {
		return e.stack && exp.test(e.stack) ? e.stack.match(exp)[1] : null
	}


	function timeoutParamDeprecationNotice(n) {
		console.error(new Error("`timeout()` as a test argument has been deprecated, use `o.timeout()`"))
		o.timeout(n)
	}

	// TODO: handle async functions?
	function validateDone(fn, error) {
		if (error == null || fn.length === 0) return
		var body = fn.toString()
		// Don't change the RegExp by hand, it is generated by
		// `scripts/build-done-parser.js`.
		// If needed, update the script and paste its output here.
		var arg = (body.match(/^(?:(?:function(?:\s|\/\*[^]*?\*\/|\/\/[^\n]*\n)*(?:\b[^\s(\/]+(?:\s|\/\*[^]*?\*\/|\/\/[^\n]*\n)*)?)?\((?:\s|\/\*[^]*?\*\/|\/\/[^\n]*\n)*)?([^\s{[),=\/]+)/) || []).pop()
		if (arg) {
			if(body.indexOf(arg) === body.lastIndexOf(arg)) {
				var doneError = new Error
				doneError.stack = "'" + arg + "()' should be called at least once\n" + o.cleanStackTrace(error)
				throw doneError
			}
		} else {
			console.warn("we couldn't determine the `done` callback name, please file a bug report at https://github.com/mithriljs/ospec/issues")
			arg = "done"
		}
		return "`" + arg + "()` should only be called once"
	}

	// # Spec definition
	function Spec() {
		this.before = []
		this.beforeEach = []
		this.after = []
		this.afterEach = []
		this.specTimeout = null
		this.customAssert = null
		this.children = Object.create(null)
	}

	// Used for both user-defined tests and internal book keeping
	// Internal tasks don't have an `err`. `hookName` is only defined
	// for hooks
	function Task(fn, err, hookName) {
		// This test needs to be here rather than in `o("name", test(){})`
		// in order to also cover nested hooks.
		if (isRunning() && err != null) throw new Error("Test definitions and hooks shouldn't be nested. To group tests, use 'o.spec()'")
		this.context = null
		this.file = $file
		// give tests an extra level of depth (simplifies bail out logic)
		this.depth = $depth + (hookName == null ? 1 : 0)
		this.doneTwiceError = !$localAssertions && validateDone(fn, err) || "A thenable should only be resolved once"
		this.error = err
		this.internal = err == null
		this.fn = fn
		this.hookName = hookName
		this.localAssertions = $localAssertions
	}

	function hook(name) {
		return function(predicate) {
			if ($context[name].length > 0) throw new Error("Attempt to register o." + name + "() more than once. A spec can only have one hook of each kind")
			$context[name][0] = new Task(predicate, ensureStackTrace(new Error), name)
		}
	}

	function unique(subject) {
		if (hasOwn.call($context.children, subject)) {
			console.warn("A test or a spec named '" + subject + "' was already defined in this spec")
			console.warn(o.cleanStackTrace(ensureStackTrace(new Error)).split("\n")[0])
			while (hasOwn.call($context.children, subject)) subject += "*"
		}
		return subject
	}

	// # API
	function o(subject, predicate) {
		if (predicate === undefined) {
			if (!isRunning()) throw new Error("Assertions should not occur outside test definitions")
			if ($task.localAssertions) throw new SyntaxError("Illegal global assertion, use a local `o()`")
			return new Assertion(subject)
		} else {
			subject = String(subject)
			$context.children[unique(subject)] = new Task(predicate, ensureStackTrace(new Error), null)
		}
	}
	function noSpecOrTestHasBeenDefined() {
		return $context === rootSpec
		&& Object.keys(rootSpec).every(k => {
			const item = rootSpec[k]
			return item == null || (Array.isArray(item) ? item : Object.keys(item)).length === 0
		})
	}
	o.globalAssertions = function(cb) {
		if (isRunning()) throw new SyntaxError("local/global modes can only be called before o.run()")
		if (cb === "override"){
			// escape hatch for the CLI test suite
			// ideally we should use --preload that requires
			// in depth rethinking of the CLI test suite that I'd rather
			// avoid while changing the core at the same time.
			$localAssertions = false
			return
		} else if (cb == null) {
			if (noSpecOrTestHasBeenDefined()) {
				$localAssertions = false
				return
			} else {
				throw new SyntaxError("local/global mode can only be toggled before defining specs and tests")
			}
		} else {
			const previous = $localAssertions
			try {
				$localAssertions = false
				cb()
			} finally {
				$localAssertions = previous
			}
		}
	}
	o.localAssertions = function(cb) {
		if (isRunning()) throw new SyntaxError("local/global modes can only be called before o.run()")
		if (cb === "override"){
			// escape hatch for the CLI test suite
			// ideally we should use --preload that requires
			// in depth rethinking of the CLI test suite that I'd rather
			// avoid while changing the core at the same time.
			$localAssertions = true
			return
		} if (cb == null) {
			if (noSpecOrTestHasBeenDefined()) {
				$localAssertions = true
			} else {
				throw new SyntaxError("local/global mode can only be toggled before defining specs and tests")
			}
		} else {
			const previous = $localAssertions
			try {
				$localAssertions = true
				cb()
			} finally {
				$localAssertions = previous
			}
		}
	}

	o.before = hook("before")
	o.after = hook("after")
	o.beforeEach = hook("beforeEach")
	o.afterEach = hook("afterEach")

	o.specTimeout = function (t) {
		if (isRunning()) throw new Error("o.specTimeout() can only be called before o.run()")
		if ($context.specTimeout != null) throw new Error("A default timeout has already been defined in this context")
		if (typeof t !== "number") throw new Error("o.specTimeout() expects a number as argument")
		$context.specTimeout = t
	}

	o.new = init

	o.spec = function(subject, predicate) {
		if (isRunning()) throw new Error("`o.spec()` can't only be called at test definition time, not run time")
		// stack managed globals
		var parent = $context
		var name = unique(subject)
		$context = $context.children[name] = new Spec()
		$depth++
		try {
			predicate()
		} finally {
			$depth--
			$context = parent
		}
	}

	var onlyCalledAt = []
	o.only = function(subject, predicate) {
		onlyCalledAt.push(o.cleanStackTrace(ensureStackTrace(new Error)).split("\n")[0])
		only.push(predicate)
		o(subject, predicate)
	}

	o.cleanStackTrace = function(error) {
		// For IE 10+ in quirks mode, and IE 9- in any mode, errors don't have a stack
		if (error.stack == null) return ""
		var header = error.message ? error.name + ": " + error.message : error.name, stack
		// some environments add the name and message to the stack trace
		if (error.stack.indexOf(header) === 0) {
			stack = error.stack.slice(header.length).split(/\r?\n/)
			stack.shift() // drop the initial empty string
		} else {
			stack = error.stack.split(/\r?\n/)
		}
		if (ospecFileName == null) return stack.join("\n")
		// skip ospec-related entries on the stack
		return stack.filter(function(line) { return line.indexOf(ospecFileName) === -1 }).join("\n")
	}

	o.timeout = function(n) {
		$timeout(n)
	}

	// # Test runner
	var stack = []
	var scheduled = false
	function cycleStack() {
		try {
			while (stack.length) stack.shift()()
		} finally {
			// Don't stop on error, but still let it propagate to the host as usual.
			if (stack.length) setTimeout(cycleStack, 0)
			else scheduled = false
		}
	}
	/* eslint-disable indent */
	var nextTickish = hasProcess
		? process.nextTick
		: typeof Promise === "function"
		? Promise.prototype.then.bind(Promise.resolve())
		: function fakeFastNextTick(next) {
			if (!scheduled) {
				scheduled = true
				setTimeout(cycleStack, 0)
			}
			stack.push(next)
		}
	/* eslint-enable indent */
	o.metadata = function(opts) {
		if (arguments.length === 0) {
			if (!isRunning()) throw new Error("getting `o.metadata()` is only allowed at test run time")
			return {
				file: $task.file,
				name: $task.context
			}
		} else {
			if (isRunning() || $context !== rootSpec) throw new Error("setting `o.metadata()` is only allowed at the root, at test definition time")
			$file = opts.file
		}
	}

	o.run = function(reporter) {
		if (rootSpec !== $context) throw new Error("`o.run()` can't be called from within a spec")
		if (isRunning()) throw new Error("`o.run()` has already been called")
		results = []
		stats = {
			bailCount: 0,
			onlyCalledAt: onlyCalledAt
		}

		if (hasSuiteName) {
			var parent = new Spec()
			parent.children[name] = rootSpec
		}

		var finalize = new Task(function() {
			timeoutStackName = getStackName({stack: o.cleanStackTrace(ensureStackTrace(new Error))}, /([w .]+?:d+:d+)/)
			if (typeof reporter === "function") reporter(results, stats)
			else {
				var errCount = o.report(results, stats)
				if (hasProcess) process.exit(errCount !== 0 ? 1 : undefined) // eslint-disable-line no-process-exit
			}
		}, null, null)

		// always async for consistent external behavior
		// otherwise, an async test would release Zalgo
		// https://blog.izs.me/2013/08/designing-apis-for-asynchrony
		nextTickish(function () {
			runSpec(hasSuiteName ? parent : rootSpec, [], [], finalize, 200 /*default timeout delay*/)
		})

		function runSpec(spec, beforeEach, afterEach, finalize, defaultDelay) {
			var bailed = false
			if (spec.specTimeout) defaultDelay = spec.specTimeout

			// stack-managed globals
			var previousBail = $bail
			$bail = function() {bailed = true; stats.bailCount++}
			var restoreStack = new Task(function() {
				$bail = previousBail
			}, null, null)

			beforeEach = [].concat(
				beforeEach,
				spec.beforeEach
			)
			afterEach = [].concat(
				spec.afterEach,
				afterEach
			)
			series(
				[].concat(
					spec.before,
					Object.keys(spec.children).reduce(function(tasks, key) {
						if (
							// If in `only` mode, skip the tasks that are not flagged to run.
							only.length === 0
							|| only.indexOf(spec.children[key].fn) !== -1
							// Always run specs though, in case there are `only` tests nested in there.
							|| !(spec.children[key] instanceof Task)
						) {
							tasks.push(new Task(function(done) {
								if (bailed) return done()
								subjects.push(key)
								var popSubjects = new Task(function pop() {subjects.pop(); done()}, null, null)
								if (spec.children[key] instanceof Task) {
									// this is a test
									series(
										[].concat(beforeEach, spec.children[key], afterEach, popSubjects),
										defaultDelay
									)
								} else {
									// a spec...
									runSpec(spec.children[key], beforeEach, afterEach, popSubjects, defaultDelay)
								}
							}, null, null))
						}
						return tasks
					}, []),
					spec.after,
					restoreStack,
					finalize
				),
				defaultDelay
			)
		}

		// Executes a list of tasks in series.
		// This is quite convoluted because we handle both sync and async tasks.
		// Async tasks can either use a legacy `done(error?)` API, or return a
		// thenable, which may or may not behave like a Promise
		function series(tasks, defaultDelay) {
			var cursor = 0
			next()

			function next() {
				if (cursor === tasks.length) return

				// const
				var task = tasks[cursor++]
				var fn = task.fn
				var isHook = task.hookName != null
				var taskStartTime = new Date

				// let
				var delay = defaultDelay
				var hasMovedOn = false
				var hasConcluded = false
				var timeout

				var isDone = false
				var isAsync = false
				var promises = []

				if (task.internal) {
					// internal tasks still use the legacy done() system.
					// handled hereafter in a simplified fashion, without timeout
					// and bailout handling (let it crash)
					if (fn.length === 0) {
						fn()
						next()
					}
					else fn(function() {
						if (hasMovedOn) throw new Error("Internal Error, done() should only be called once")
						hasMovedOn = true
						next()
					})
					return
				}

				$task = task
				task.context = subjects.join(" > ")
				if (isHook) {
					task.context = "o." + task.hookName + Array.apply(null, {length: task.depth}).join("*") + "( " + task.context + " )"
				}

				$timeout = function timeout (t) {
					if (isAsync || hasConcluded || isDone) throw new Error("`o.timeout()` must be called synchronously from within a test definition or a hook")
					if (typeof t !== "number") throw new Error("timeout() and o.timeout() expect a number as argument")
					delay = t
				}
				if (task.localAssertions) {
					var assert = function o(value) {

						return new Assertion(value, task)
					}
					assert.metadata = o.metadata
					assert.timeout = o.timeout
					assert.spy = createSpy(function(self, args, fn, spy) {
						if (hasConcluded) fail(new Assertion().i, "spy ran after its test was concluded\n"+fn.toString())
						return globalSpyHelper(self, args, fn, spy)
					})
					assert.o = assert

					Object.defineProperty(assert, "done", {get(){
						let f, r
						promises.push(new Promise((_f, _r)=>{f = _f, r = _r}))
						function done(x){
							return x == null ? f() : r(x)
						}
						return done
					}})

					// runs when a test had an error or returned a promise
					const conclude = (err, threw) => {
						if (threw) {
							if (err instanceof Error) fail(new Assertion().i, err.message, err)
							else fail(new Assertion().i, String(err), null)
							$bail()
							if (task.hookName === "beforeEach") {
								while (!task.internal && tasks[cursor].depth > task.depth) cursor++
							}
						}
						if (timeout !== undefined) {
							timeout = clearTimeout(timeout)
						}
						hasConcluded = true
						// if the timeout already expired, the suite has moved on.
						// Doing it again would be a bug.
						if (!hasMovedOn) moveOn()

					}
					// hops on to the next task after either conclusion or timeout,
					// whichever comes first
					const moveOn = () => {
						hasMovedOn = true
						if (isAsync) next()
						else nextTickish(next)
					}
					const startTimer = () => {
						timeout = setTimeout(function() {
							timeout = undefined
							fail(new Assertion().i, "async test timed out after " + delay + "ms", null)
							moveOn()
						}, Math.min(delay, 0x7fffffff))

					}
					try {
						var result = fn(assert)
						if (result != null && typeof result.then === 'function') {
							// normalize thenables so that we only conclude once
							promises.push(Promise.resolve(result))
						}
						if (promises.length > 0) {
							Promise.all(promises).then(
								function() {conclude()},
								function(e) {conclude(e,true)}
							)
							isAsync = true
							startTimer()
						} else {
							hasConcluded = true
							moveOn()
						}
					} catch(e) {
						conclude(e, true)
					}
					return
				}
				// for the legacy API
				try {
					if (fn.length > 0) {
						fn(done, timeoutParamDeprecationNotice)
					} else {
						var prm = fn()
						if (prm && prm.then) {
							// Use `_done`, not `finalize` here to defend against badly behaved thenables.
							// Let it crash if `then()` doesn't work as expected.
							prm.then(function() { _done(null, false) }, function(e) {_done(e, true)})
						} else {
							finalize(null, false, false)
						}
					}
					if (!hasMovedOn) {
						// done()/_done() haven't been called synchronously
						isAsync = true
						startTimer()
					}
				}
				catch (e) {
					finalize(e, true, false)
				}

				// public API, may only be called once from user code (or after the resolution
				// of a thenable that's been returned at the end of the test)
				function done(err) {
					// `!!err` would be more correct as far as node callback go, but we've been
					// using a `err != null` test for a while and no one complained...
					_done(err, err != null)
				}
				// common abstraction for node-style callbacks and thenables
				function _done(err, threw) {
					if (isDone) throw new Error(task.doneTwiceError)
					isDone = true
					if (isAsync && timeout === undefined) {
						$timedOutAndPendingResolution--
						console.warn(
							task.context
							+ "\n# elapsed: " + Math.round(new Date - taskStartTime)
							+ "ms, expected under " + delay + "ms\n"
							+ o.cleanStackTrace(task.error))
					}


					if (!hasMovedOn) finalize(err, threw, false)
				}
				// called only for async tests
				function startTimer() {
					timeout = setTimeout(function() {
						timeout = undefined
						$timedOutAndPendingResolution++
						finalize("async test timed out after " + delay + "ms\nWarning: assertions starting with `???` may not be properly labelled", true, true)
					}, Math.min(delay, 0x7fffffff))
				}
				// common test finalization code path, for internal use only
				function finalize(err, threw, isTimeout) {
					if (hasMovedOn) {
						// failsafe for hacking, should never happen in released code
						throw new Error("Multiple finalization")
					}
					hasMovedOn = true

					if (threw) {
						if (err instanceof Error) fail(new Assertion().i, err.message, err)
						else fail(new Assertion().i, String(err), null)
						if (!isTimeout) {
							$bail()
							if (task.hookName === "beforeEach") {
								while (!task.internal != null && tasks[cursor].depth > task.depth) cursor++
							}
						}
					}
					if (timeout !== undefined) timeout = clearTimeout(timeout)

					if (isAsync) next()
					else nextTickish(next)
				}
			}
		}
	}

	// #Assertions
	function Assertion(value) {
		this.value = value
		this.i = results.length
		results.push({
			pass: null,
			message: "Incomplete assertion in the test definition starting at...",
			error: $task.error,
			task: $task,
			timeoutLimbo: $timedOutAndPendingResolution === 0,
			// Deprecated
			context: ($timedOutAndPendingResolution === 0 ? "" : "??? ") + $task.context,
			testError: $task.error
		})
	}

	function plainAssertion(verb, compare) {
		return function(self, value) {
			var success = compare(self.value, value)
			var message = serialize(self.value) + "\n  " + verb + "\n" + serialize(value)
			if (success) succeed(self.i, message, null)
			else fail(self.i, message, null)
		}
	}

	function define(name, assertion) {
		Assertion.prototype[name] = function assert(value) {
			var self = this
			assertion(self, value)
			return function(message) {
				if (Array.isArray(message)) {
					// We got a tagged template literal,
					// we'll interpolate the dynamic values.
					var args = arguments
					message = message.reduce(function(acc, v, i) {return acc + args[i] + v})
				}
				results[self.i].message = message + "\n\n" + results[self.i].message
			}
		}
	}

	define("equals", plainAssertion("should equal", function(a, b) {return a === b}))
	define("notEquals", plainAssertion("should not equal", function(a, b) {return a !== b}))
	define("deepEquals", plainAssertion("should deep equal", deepEqual))
	define("notDeepEquals", plainAssertion("should not deep equal", function(a, b) {return !deepEqual(a, b)}))
	define("throws", plainAssertion("should throw a", throws))
	define("notThrows", plainAssertion("should not throw a", function(a, b) {return !throws(a, b)}))
	define("satisfies", function satisfies(self, check) {
		try {
			var res = check(self.value)
			if (res.pass) succeed(self.i, String(res.message), null)
			else fail(self.i, String(res.message), null)
		} catch (e) {
			results.pop()
			throw e
		}
	})
	Assertion.prototype._ = Assertion.prototype.satisfies
	define("notSatisfies", function notSatisfies(self, check) {
		try {
			var res = check(self.value)
			if (!res.pass) succeed(self.i, String(res.message), null)
			else fail(self.i, String(res.message), null)
		} catch (e) {
			results.pop()
			throw e
		}
	})
	function isArguments(a) {
		if ("callee" in a) {
			for (var i in a) if (i === "callee") return false
			return true
		}
	}
	function getEnumerableProps(x) {
		var desc = Object.getOwnPropertyDescriptors(x)
		return Object.keys(desc).filter(function(k){return desc[k].enumerable})
	}

	function deepEqual(a, b) {
		if (a === b) return true
		if (a === null ^ b === null || a === undefined ^ b === undefined) return false // eslint-disable-line no-bitwise
		if (typeof a === "object" && typeof b === "object") {
			var aIsArgs = isArguments(a), bIsArgs = isArguments(b)
			if (a.constructor === Object && b.constructor === Object && !aIsArgs && !bIsArgs || Object.getPrototypeOf(a) == null && Object.getPrototypeOf(b) == null) {
				for (var i in a) {
					if ((!(i in b)) || !deepEqual(a[i], b[i])) return false
				}
				for (var i in b) {
					if (!(i in a)) return false
				}
				return true
			}
			if (a.length === b.length && (Array.isArray(a) && Array.isArray(b) || aIsArgs && bIsArgs)) {
				var aKeys = getEnumerableProps(a), bKeys = getEnumerableProps(b)
				if (aKeys.length !== bKeys.length) return false
				for (var i = 0; i < aKeys.length; i++) {
					if (!hasOwn.call(b, aKeys[i]) || !deepEqual(a[aKeys[i]], b[aKeys[i]])) return false
				}
				return true
			}
			if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime()
			if (typeof Buffer === "function" && a instanceof Buffer && b instanceof Buffer && a.length === b.length) {
				for (var i = 0; i < a.length; i++) {
					if (a[i] !== b[i]) return false
				}
				return true
			}
			if (typeof a.valueOf !== "function" || typeof b.valueOf !== "function") return false
			if (a.valueOf() === b.valueOf()) return true
		}
		return false
	}

	function throws(a, b){
		try{
			a()
		}catch(e){
			if(typeof b === "string"){
				return (e.message === b)
			}else{
				return (e instanceof b)
			}
		}
		return false
	}

	function succeed(i, message, error) {
		var result = results[i]
		result.pass = true
		result.message = message
		// for notSatisfies. Use the task.error for other passing assertions
		if (error != null) result.error = error
	}

	function fail(i, message, error) {
		var result = results[i]
		result.pass = false
		result.message = message
		result.error = error != null ? error : ensureStackTrace(new Error)
	}
	// workaround for Rollup
	// direct `require` calles are hoisted at the top of the file
	// and ran unconditionally.

	var serialize = function serialize(value) {
		if (value === null || (typeof value === "object" && !(value instanceof Array)) || typeof value === "number") return String(value)
		else if (typeof value === "function") return value.name || "<anonymous function>"
		try {return JSON.stringify(value)} catch (e) {return String(value)}
	}
	try {serialize = require("util").inspect} catch(e) {/* deliberately empty */} // eslint-disable-line global-require

	// o.spy is functionally equivalent to this:
	// the extra complexity comes from compatibility issues
	// in ES5 environments where you can't overwrite fn.length

	// o.spy = function(fn) {
	// 	var spy = function() {
	// 		spy.this = this
	// 		spy.args = [].slice.call(arguments)
	// 		spy.calls.push({this: this, args: spy.args})
	// 		spy.callCount++

	// 		if (fn) return fn.apply(this, arguments)
	// 	}
	// 	if (fn)
	// 		Object.defineProperties(spy, {
	// 			length: {value: fn.length},
	// 			name: {value: fn.name}
	// 		})
	// 	spy.args = []
	// 	spy.calls = []
	// 	spy.callCount = 0
	// 	return spy
	// }

	var spyFactoryCache = Object.create(null)

	function makeSpyFactory(name, length) {
		if (spyFactoryCache[name] == null) spyFactoryCache[name] = []
		var args = Array.apply(null, {length: length}).map(
			function(_, i) {return "_" + i}
		).join(", ");
		var code =
			"'use strict';" +
			"var spy = (0, function " + name + "(" + args + ") {" +
			"   return helper(this, [].slice.call(arguments), fn, spy)" +
			"});" +
			"return spy"

		return spyFactoryCache[name][length] = new Function("fn", "helper", code)
	}

	function getOrMakeSpyFactory(name, length) {
		return spyFactoryCache[name] && spyFactoryCache[name][length] || makeSpyFactory(name, length)
	}

	function globalSpyHelper(self, args, fn, spy) {
		spy.this = self
		spy.args = args
		spy.calls.push({this: self, args: args})
		spy.callCount++

		if (fn) return fn.apply(self, args)
	}

	var supportsFunctionMutations = false;
	// eslint-disable-next-line no-empty, no-implicit-coercion
	try {supportsFunctionMutations = !!Object.defineProperties(function(){}, {name: {value: "a"},length: {value: 1}})} catch(_){}

	var supportsEval = false
	// eslint-disable-next-line no-new-func, no-empty
	try {supportsEval = Function("return true")()} catch(e){}

	function createSpy(helper) {
		return function spy(fn) {
			var name = "", length = 0
			if (fn) name = fn.name, length = fn.length
			var spy = (!supportsFunctionMutations && supportsEval)
				? getOrMakeSpyFactory(name, length)(fn, helper)
				: function(){return helper(this, [].slice.call(arguments), fn, spy)}
			if (supportsFunctionMutations) Object.defineProperties(spy, {
				name: {value: name},
				length: {value: length}
			})
	
			spy.args = []
			spy.calls = []
			spy.callCount = 0
			return spy
		}
	}

	o.spy = createSpy(globalSpyHelper)

	// Reporter
	var colorCodes = {
		red: "31m",
		red2: "31;1m",
		green: "32;1m"
	}

	// this is needed to work around the formating done by node see https://nodejs.org/api/util.html#utilformatformat-args
	function escapePercent(x){return String(x).replace(/%/g, "%%")}

	// console style for terminals
	// see https://stackoverflow.com/questions/4842424/list-of-ansi-color-escape-sequences
	function highlight(message, color) {
		var code = colorCodes[color] || colorCodes.red;
		return hasProcess ? (process.stdout.isTTY ? "\x1b[" + code + escapePercent(message) + "\x1b[0m" : escapePercent(message)) : "%c" + message + "%c "
	}

	// console style for the Browsers
	// see https://developer.mozilla.org/en-US/docs/Web/API/console#Styling_console_output
	function cStyle(color, bold) {
		return hasProcess||!color ? "" : "color:"+color+(bold ? ";font-weight:bold" : "")
	}

	function onlyWarning(onlyCalledAt) {
		var colors = Math.random() > 0.5
			? {
				term: "red2",
				web: cStyle("red", true)
			}
			: {
				term: "re",
				web: cStyle("red")
			}
		if (onlyCalledAt && onlyCalledAt.length !== 0) {
			console.warn(
				highlight("\nWarning: o.only() called...\n", colors.term),
				colors.web, ""
			)
			console.warn(onlyCalledAt.join("\n"))
			console.warn(
				highlight("\nWarning: o.only()\n", colors.term),
				colors.web, ""
			)
		}
	}

	o.report = function (results, stats) {
		if (stats == null) stats = {bailCount: 0}
		var errCount = -stats.bailCount
		for (var i = 0, r; r = results[i]; i++) {
			if (!r.pass) {
				var stackTrace = o.cleanStackTrace(r.error)
				var couldHaveABetterStackTrace = !stackTrace || timeoutStackName != null && stackTrace.indexOf(timeoutStackName) !== -1 && stackTrace.indexOf("\n") === -1
				if (couldHaveABetterStackTrace) stackTrace = r.task.error != null ? o.cleanStackTrace(r.task.error) : r.error.stack || ""
				console.error(
					(hasProcess ? "\n" : "") +
					(r.task.timeoutLimbo ? "??? " : "") +
					highlight(r.task.context + ":", "red2") + "\n" +
					highlight(r.message, "red") +
					(stackTrace ? "\n" + stackTrace + "\n" : ""),

					cStyle("black", true), cStyle(null), // reset to default
					cStyle("red"), cStyle("black")
				)
				errCount++
			}
		}
		var pl = results.length === 1 ? "" : "s"

		var total = results.length - stats.bailCount
		var message = [], log = []

		if (hasProcess) message.push("––––––\n")

		if (name) message.push(name + ": ")

		if (errCount === 0 && stats.bailCount === 0) {
			message.push(highlight((pl ? "All " : "The ") + total + " assertion" + pl + " passed", "green"))
			log.push(cStyle("green" , true), cStyle(null))
		} else if (errCount === 0) {
			message.push((pl ? "All " : "The ") + total + " assertion" + pl + " passed")
		} else {
			message.push(highlight(errCount + " out of " + total + " assertion" + pl + " failed", "red2"))
			log.push(cStyle("red" , true), cStyle(null))
		}

		if (stats.bailCount !== 0) {
			message.push(highlight(". Bailed out " + stats.bailCount + (stats.bailCount === 1 ? " time" : " times"), "red"))
			log.push(cStyle("red"), cStyle(null))
		}

		log.unshift(message.join(""))
		console.log.apply(console, log)

		onlyWarning(stats.onlyCalledAt)

		return errCount + stats.bailCount
	}
	return o
})
